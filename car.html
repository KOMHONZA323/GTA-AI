<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realistic Car Physics Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #0a0a0a; font-family: 'Courier New', monospace; }
        canvas { display: block; }
        
        .hud-panel {
            background: rgba(0, 20, 40, 0.9);
            border: 2px solid #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
            color: #00ff88;
        }
        
        .rpm-bar {
            background: linear-gradient(90deg, #00ff88 0%, #ffff00 70%, #ff0000 100%);
            height: 100%;
            transition: width 0.05s linear;
        }
        
        .gear-display {
            font-size: 4rem;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
        }
        
        .analog-gauge {
            position: relative;
            width: 180px;
            height: 180px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #1a1a2e, #0a0a0a);
            border: 4px solid #333;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.8), 0 0 20px rgba(0,0,0,0.5);
        }
        
        .gauge-needle {
            position: absolute;
            bottom: 50%;
            left: 50%;
            width: 4px;
            height: 70px;
            background: #ff0000;
            transform-origin: bottom center;
            transform: translateX(-50%) rotate(-135deg);
            transition: transform 0.05s linear;
            box-shadow: 0 0 10px rgba(255,0,0,0.8);
            border-radius: 2px;
        }
        
        .gauge-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 16px;
            height: 16px;
            background: #333;
            border-radius: 50%;
            border: 2px solid #666;
        }
        
        .speed-text {
            position: absolute;
            bottom: 25%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 2rem;
            font-weight: bold;
            color: #fff;
        }
        
        .kmh-label {
            position: absolute;
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7rem;
            color: #666;
        }
        
        .control-key {
            display: inline-block;
            padding: 8px 16px;
            margin: 4px;
            background: #222;
            border: 2px solid #444;
            border-radius: 8px;
            color: #fff;
            font-weight: bold;
            box-shadow: 0 4px 0 #000;
            cursor: pointer;
            user-select: none;
        }
        
        .control-key.active {
            background: #00ff88;
            color: #000;
            border-color: #00ff88;
            box-shadow: 0 2px 0 #004422;
            transform: translateY(2px);
        }
        
        .telemetry {
            font-size: 0.8rem;
            line-height: 1.4;
        }
        
        .redline { color: #ff0000; text-shadow: 0 0 10px rgba(255,0,0,0.8); }
        
        .shift-light {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #333;
            display: inline-block;
            margin: 0 2px;
            transition: all 0.1s;
            border: 1px solid #555;
        }
        .shift-light.on {
            background: #ff0000;
            box-shadow: 0 0 15px #ff0000, 0 0 30px #ff0000;
            border-color: #ff6666;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            75% { transform: translateX(2px); }
        }
        .shaking { animation: shake 0.1s infinite; }
        
        .light-btn {
            transition: all 0.3s;
        }
        .light-btn.on {
            background: #ffff00;
            color: #000;
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.6);
        }
    </style>
</head>
<body>

    <!-- HUD Interface -->
    <div class="absolute top-0 left-0 w-full h-full pointer-events-none z-10 flex flex-col justify-between p-6">
        
        <!-- Top Bar -->
        <div class="flex justify-between items-start">
            <div class="hud-panel rounded-xl p-4 pointer-events-auto">
                <h1 class="text-xl font-bold mb-2 tracking-wider">PHYSICS SIMULATION</h1>
                <div class="telemetry text-xs space-y-1">
                    <div>GEAR RATIO: <span id="gearRatio">0.00</span></div>
                    <div>TORQUE: <span id="torqueVal">0</span> Nm</div>
                    <div>DRAG FORCE: <span id="dragForce">0</span> N</div>
                    <div>WEIGHT TRANSFER: <span id="weightTransfer">0</span>%</div>
                    <div>ABS STATUS: <span id="absStatus" class="text-gray-500">OFF</span></div>
                </div>
            </div>
            
            <div class="hud-panel rounded-xl p-4 pointer-events-auto flex flex-col items-center gap-2">
                <div class="text-xs tracking-widest mb-1">SHIFT LIGHTS</div>
                <div class="flex justify-center gap-1">
                    <div class="shift-light" id="sl1"></div>
                    <div class="shift-light" id="sl2"></div>
                    <div class="shift-light" id="sl3"></div>
                    <div class="shift-light" id="sl4"></div>
                    <div class="shift-light" id="sl5"></div>
                </div>
                <button id="lightBtn" onclick="toggleLights()" class="light-btn mt-2 px-4 py-2 bg-gray-800 border border-gray-600 rounded text-xs font-bold pointer-events-auto">
                    LIGHTS: ON
                </button>
            </div>
        </div>

        <!-- Middle Left - Speedometer -->
        <div class="absolute top-1/2 left-6 transform -translate-y-1/2 pointer-events-none">
            <div class="hud-panel rounded-2xl p-4 flex flex-col items-center">
                <div class="text-xs tracking-widest mb-2 text-gray-400">SPEED</div>
                <div class="analog-gauge">
                    <div class="gauge-needle" id="speedNeedle"></div>
                    <div class="gauge-center"></div>
                    <div class="speed-text"><span id="speedDisplay">0</span></div>
                    <div class="kmh-label">KM/H</div>
                </div>
            </div>
        </div>

        <!-- Bottom Controls -->
        <div class="flex justify-between items-end">
            <div class="hud-panel rounded-xl p-6 pointer-events-auto">
                <div class="flex items-center gap-4 mb-4">
                    <div class="gear-display" id="gearDisplay">1</div>
                    <div>
                        <div class="text-xs text-gray-400">RPM</div>
                        <div class="text-2xl font-bold" id="rpmDisplay">800</div>
                    </div>
                </div>
                
                <div class="w-64 h-4 bg-gray-800 rounded-full overflow-hidden border border-gray-600">
                    <div class="rpm-bar" id="rpmBar" style="width: 8%"></div>
                </div>
                <div class="flex justify-between text-xs mt-1">
                    <span>0</span>
                    <span id="redlineStart" class="redline">6000</span>
                    <span>8000</span>
                </div>
            </div>

            <div class="hud-panel rounded-xl p-4 pointer-events-auto">
                <div class="text-xs mb-3 tracking-widest text-center">CONTROLS</div>
                <div class="flex flex-col gap-2 items-center">
                    <div class="control-key" id="keyW">W</div>
                    <div class="flex gap-2">
                        <div class="control-key" id="keyA">A</div>
                        <div class="control-key" id="keyS">S</div>
                        <div class="control-key" id="keyD">D</div>
                    </div>
                    <div class="text-xs text-gray-400 mt-2">SPACE: BRAKE | SHIFT: UP | CTRL: DOWN</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // ==========================================
        // PHYSICS ENGINE CONFIGURATION - TUNED FOR REALISTIC SPEEDS
        // ==========================================
        
        const PHYSICS = {
            // Engine specs - lower redline for realism
            maxRPM: 8000,
            idleRPM: 800,
            redline: 6000,
            maxTorque: 320, // Lower torque for slower acceleration
            torquePeakRPM: 3500,
            
            // Gear ratios tuned for ~140 km/h in 4th gear at redline
            // 4th gear ratio calculated: Speed = (RPM * 60 * 2π * wheelRadius) / (gearRatio * finalDrive * 1000/3600)
            // Target: 140 km/h at 6000 RPM in 4th
            gearRatios: [0, 4.2, 2.5, 1.6, 1.0, 0.75, 0.60],
            finalDrive: 4.1, // Higher final drive for better acceleration, lower top speed
            
            wheelRadius: 0.35, // meters
            
            // Physics constants - increased drag for lower top speeds
            mass: 1400,
            dragCoefficient: 0.32,
            frontalArea: 2.3,
            airDensity: 1.225,
            rollingResistance: 0.018,
            brakeForce: 10000,
            absThreshold: 5,
            
            suspensionStiffness: 0.3,
            suspensionDamping: 0.8
        };

        let carState = {
            speed: 0,
            rpm: PHYSICS.idleRPM,
            gear: 1,
            throttle: 0,
            brake: 0,
            clutch: 0,
            steering: 0,
            distance: 0,
            
            wheelRotation: 0,
            engineAngularVel: 0,
            isABSActive: false,
            shiftTimer: 0,
            
            suspensionCompression: { front: 0, rear: 0 },
            bodyPitch: 0,
            bodyRoll: 0
        };

        const keys = { w: false, a: false, s: false, d: false, space: false, shift: false, ctrl: false };
        let lightsOn = true;
        let headLightObjects = [];
        let tailLightObjects = [];

        let scene, camera, renderer, controls;
        let carGroup, chassis, wheels = [], steeringWheel;
        let lastTime = 0;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            scene.fog = new THREE.Fog(0x0a0a0a, 20, 100);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(6, 4, 10);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.maxPolarAngle = Math.PI / 2 - 0.05;
            controls.minDistance = 3;
            controls.maxDistance = 30;

            createEnvironment();
            createDetailedCar();
            setupLighting();

            setupInputs();
            
            requestAnimationFrame(animate);
        }

        function createEnvironment() {
            const groundGeometry = new THREE.PlaneGeometry(500, 500);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x151515,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            const grid = new THREE.GridHelper(500, 100, 0x333333, 0x222222);
            grid.position.y = 0.01;
            scene.add(grid);

            for (let i = -200; i < 200; i += 20) {
                const line = new THREE.Mesh(
                    new THREE.PlaneGeometry(1, 10),
                    new THREE.MeshBasicMaterial({ color: 0xffffff })
                );
                line.rotation.x = -Math.PI / 2;
                line.position.set(0, 0.02, i);
                scene.add(line);
            }

            for (let i = -100; i < 100; i += 20) {
                const pole = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 4),
                    new THREE.MeshStandardMaterial({ color: 0x666666 })
                );
                pole.position.set(10, 2, i);
                scene.add(pole);

                const bulb = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3),
                    new THREE.MeshBasicMaterial({ color: 0xffffaa })
                );
                bulb.position.set(10, 4, i);
                scene.add(bulb);

                const pole2 = pole.clone();
                pole2.position.set(-10, 2, i);
                scene.add(pole2);

                const bulb2 = bulb.clone();
                bulb2.position.set(-10, 4, i);
                scene.add(bulb2);
            }
        }

        function createDetailedCar() {
            carGroup = new THREE.Group();

            const carPaint = new THREE.MeshPhysicalMaterial({
                color: 0xcc0000,
                metalness: 0.6,
                roughness: 0.2,
                clearcoat: 1.0,
                clearcoatRoughness: 0.03
            });

            const blackTrim = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.5 });
            const glassMat = new THREE.MeshPhysicalMaterial({
                color: 0x111111,
                metalness: 0.9,
                roughness: 0.0,
                transparent: true,
                opacity: 0.6
            });

            const chassisGeom = new THREE.BoxGeometry(2, 0.6, 4.5);
            chassis = new THREE.Mesh(chassisGeom, carPaint);
            chassis.position.y = 0.8;
            chassis.castShadow = true;
            carGroup.add(chassis);

            const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.5, 2.3), carPaint);
            cabin.position.set(0, 1.35, -0.2);
            cabin.castShadow = true;
            carGroup.add(cabin);

            const windshield = new THREE.Mesh(new THREE.PlaneGeometry(1.6, 0.9), glassMat);
            windshield.position.set(0, 1.4, 0.96);
            windshield.rotation.x = -Math.PI / 3;
            carGroup.add(windshield);

            const rearWindow = new THREE.Mesh(new THREE.PlaneGeometry(1.6, 0.8), glassMat);
            rearWindow.position.set(0, 1.4, -1.36);
            rearWindow.rotation.x = Math.PI / 3;
            rearWindow.rotation.y = Math.PI;
            carGroup.add(rearWindow);

            const wheelPositions = [
                { x: 1.1, z: 1.4, name: 'FL' },
                { x: -1.1, z: 1.4, name: 'FR' },
                { x: 1.1, z: -1.4, name: 'RL' },
                { x: -1.1, z: -1.4, name: 'RR' }
            ];

            wheelPositions.forEach(pos => {
                const wheelGroup = new THREE.Group();
                
                const tire = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.35, 0.35, 0.28, 32),
                    new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.9 })
                );
                tire.rotation.z = Math.PI / 2;
                tire.castShadow = true;
                wheelGroup.add(tire);

                const rim = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.22, 0.22, 0.29, 16),
                    new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.9, roughness: 0.1 })
                );
                rim.rotation.z = Math.PI / 2;
                wheelGroup.add(rim);

                for(let i = 0; i < 5; i++) {
                    const spoke = new THREE.Mesh(
                        new THREE.BoxGeometry(0.32, 0.06, 0.3),
                        new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.9 })
                    );
                    spoke.rotation.z = Math.PI / 2;
                    spoke.rotation.x = (i / 5) * Math.PI * 2;
                    wheelGroup.add(spoke);
                }

                const disc = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.26, 0.26, 0.03, 32),
                    new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8 })
                );
                disc.rotation.z = Math.PI / 2;
                wheelGroup.add(disc);

                const caliper = new THREE.Mesh(
                    new THREE.BoxGeometry(0.12, 0.25, 0.06),
                    new THREE.MeshStandardMaterial({ color: 0xff0000, metalness: 0.5 })
                );
                caliper.position.set(pos.x > 0 ? 0.15 : -0.15, 0.05, 0);
                wheelGroup.add(caliper);

                wheelGroup.position.set(pos.x, 0.35, pos.z);
                wheels.push(wheelGroup);
                carGroup.add(wheelGroup);
            });

            steeringWheel = new THREE.Mesh(
                new THREE.TorusGeometry(0.18, 0.025, 8, 32),
                new THREE.MeshStandardMaterial({ color: 0x333333 })
            );
            steeringWheel.position.set(0, 1.15, 0.6);
            steeringWheel.rotation.x = -Math.PI / 3;
            carGroup.add(steeringWheel);

            const headlightGeom = new THREE.BoxGeometry(0.5, 0.2, 0.1);
            const headlightMat = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, 
                emissive: 0xffffff, 
                emissiveIntensity: 0.8 
            });
            
            const hlLeft = new THREE.Mesh(headlightGeom, headlightMat);
            hlLeft.position.set(0.7, 0.75, 2.26);
            carGroup.add(hlLeft);
            headLightObjects.push(hlLeft);

            const hlRight = hlLeft.clone();
            hlRight.position.set(-0.7, 0.75, 2.26);
            carGroup.add(hlRight);
            headLightObjects.push(hlRight);

            const tailMat = new THREE.MeshStandardMaterial({ 
                color: 0xff0000, 
                emissive: 0xff0000, 
                emissiveIntensity: 0.8 
            });
            const tlLeft = new THREE.Mesh(headlightGeom, tailMat);
            tlLeft.position.set(0.7, 0.8, -2.26);
            carGroup.add(tlLeft);
            tailLightObjects.push(tlLeft);

            const tlRight = tlLeft.clone();
            tlRight.position.set(-0.7, 0.8, -2.26);
            carGroup.add(tlRight);
            tailLightObjects.push(tlRight);

            const spoiler = new THREE.Mesh(
                new THREE.BoxGeometry(1.9, 0.08, 0.4),
                blackTrim
            );
            spoiler.position.set(0, 1.45, -2.1);
            carGroup.add(spoiler);

            const exhaust = new THREE.Mesh(
                new THREE.CylinderGeometry(0.08, 0.08, 0.3),
                new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.8 })
            );
            exhaust.rotation.z = Math.PI / 2;
            exhaust.position.set(0.5, 0.35, -2.3);
            carGroup.add(exhaust);

            const exhaust2 = exhaust.clone();
            exhaust2.position.set(-0.5, 0.35, -2.3);
            carGroup.add(exhaust2);

            scene.add(carGroup);
        }

        function setupLighting() {
            const ambient = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambient);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            const leftBeam = new THREE.SpotLight(0xffffff, 3);
            leftBeam.position.set(0.7, 0.75, 2.3);
            leftBeam.target.position.set(0.7, 0, 30);
            leftBeam.angle = Math.PI / 5;
            leftBeam.penumbra = 0.2;
            leftBeam.distance = 50;
            leftBeam.castShadow = true;
            carGroup.add(leftBeam);
            carGroup.add(leftBeam.target);
            headLightObjects.push(leftBeam);

            const rightBeam = new THREE.SpotLight(0xffffff, 3);
            rightBeam.position.set(-0.7, 0.75, 2.3);
            rightBeam.target.position.set(-0.7, 0, 30);
            rightBeam.angle = Math.PI / 5;
            rightBeam.penumbra = 0.2;
            rightBeam.distance = 50;
            rightBeam.castShadow = true;
            carGroup.add(rightBeam);
            carGroup.add(rightBeam.target);
            headLightObjects.push(rightBeam);
        }

        function toggleLights() {
            lightsOn = !lightsOn;
            const btn = document.getElementById('lightBtn');
            btn.textContent = lightsOn ? 'LIGHTS: ON' : 'LIGHTS: OFF';
            btn.classList.toggle('on', lightsOn);

            headLightObjects.forEach(obj => {
                if (obj.isMesh) {
                    obj.material.emissiveIntensity = lightsOn ? 0.8 : 0.1;
                } else if (obj.isLight) {
                    obj.intensity = lightsOn ? 3 : 0;
                }
            });

            tailLightObjects.forEach(obj => {
                obj.material.emissiveIntensity = lightsOn ? 0.8 : 0.2;
            });
        }

        function setupInputs() {
            window.addEventListener('keydown', (e) => {
                const code = e.code;
                
                if (code === 'KeyW' || code === 'ArrowUp') {
                    keys.w = true;
                    document.getElementById('keyW').classList.add('active');
                }
                if (code === 'KeyS' || code === 'ArrowDown') {
                    keys.s = true;
                    document.getElementById('keyS').classList.add('active');
                }
                if (code === 'KeyA' || code === 'ArrowLeft') {
                    keys.a = true;
                    document.getElementById('keyA').classList.add('active');
                }
                if (code === 'KeyD' || code === 'ArrowRight') {
                    keys.d = true;
                    document.getElementById('keyD').classList.add('active');
                }
                if (code === 'Space') keys.space = true;
                if (code === 'ShiftLeft' || code === 'ShiftRight') {
                    keys.shift = true;
                    if (carState.gear < 6) shiftUp();
                }
                if (code === 'ControlLeft' || code === 'ControlRight') {
                    keys.ctrl = true;
                    if (carState.gear > 1) shiftDown();
                }
            });

            window.addEventListener('keyup', (e) => {
                const code = e.code;
                
                if (code === 'KeyW' || code === 'ArrowUp') {
                    keys.w = false;
                    document.getElementById('keyW').classList.remove('active');
                }
                if (code === 'KeyS' || code === 'ArrowDown') {
                    keys.s = false;
                    document.getElementById('keyS').classList.remove('active');
                }
                if (code === 'KeyA' || code === 'ArrowLeft') {
                    keys.a = false;
                    document.getElementById('keyA').classList.remove('active');
                }
                if (code === 'KeyD' || code === 'ArrowRight') {
                    keys.d = false;
                    document.getElementById('keyD').classList.remove('active');
                }
                if (code === 'Space') keys.space = false;
                if (code === 'ShiftLeft' || code === 'ShiftRight') keys.shift = false;
                if (code === 'ControlLeft' || code === 'ControlRight') keys.ctrl = false;
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // ==========================================
        // PHYSICS ENGINE - TUNED FOR REALISTIC PERFORMANCE
        // ==========================================
        
        function updatePhysics(dt) {
            if (carState.shiftTimer > 0) {
                carState.shiftTimer -= dt;
                carState.throttle = 0;
            }

            carState.throttle = keys.w ? 1 : 0;
            carState.brake = (keys.s || keys.space) ? 1 : 0;
            carState.clutch = keys.shift ? 1 : 0;

            const targetSteering = keys.a ? 0.6 : (keys.d ? -0.6 : 0);
            carState.steering += (targetSteering - carState.steering) * 8 * dt;

            // Torque curve - smoother power delivery
            let rpmRatio = carState.rpm / PHYSICS.torquePeakRPM;
            let torqueMultiplier;
            
            if (carState.rpm < PHYSICS.idleRPM) {
                torqueMultiplier = 0.1;
            } else if (carState.rpm < PHYSICS.torquePeakRPM) {
                // Rising curve
                torqueMultiplier = 0.4 + (0.6 * (carState.rpm - PHYSICS.idleRPM) / (PHYSICS.torquePeakRPM - PHYSICS.idleRPM));
            } else {
                // Falling curve after peak
                torqueMultiplier = 1.0 - ((carState.rpm - PHYSICS.torquePeakRPM) / (PHYSICS.maxRPM - PHYSICS.torquePeakRPM)) * 0.6;
            }
            
            // Redline cutoff
            if (carState.rpm > PHYSICS.redline) {
                torqueMultiplier *= Math.max(0.3, 1 - (carState.rpm - PHYSICS.redline) / 1000);
            }
            
            const currentTorque = PHYSICS.maxTorque * torqueMultiplier * carState.throttle;
            const currentGearRatio = PHYSICS.gearRatios[carState.gear];
            const totalRatio = currentGearRatio * PHYSICS.finalDrive;
            
            let tractionForce = 0;
            if (carState.gear > 0 && carState.clutch < 0.5) {
                // Traction force calculation
                tractionForce = currentTorque * totalRatio / PHYSICS.wheelRadius;
                
                // Limit traction in lower gears to prevent wheelspin simulation
                const maxTraction = 8000; // Max force tires can handle
                if (tractionForce > maxTraction) tractionForce = maxTraction;
            }

            // Drag increases with square of speed - much higher now
            const dragForce = 0.5 * PHYSICS.airDensity * PHYSICS.dragCoefficient * 
                             PHYSICS.frontalArea * (carState.speed * carState.speed);
            
            const rollingForce = PHYSICS.rollingResistance * PHYSICS.mass * 9.81;
            
            // Engine braking - stronger for better deceleration
            const engineBrakeForce = (carState.throttle === 0 && carState.gear > 0) ? 
                                     (carState.rpm * 0.012) : 0;

            let brakeForce = 0;
            if (carState.brake > 0) {
                const decel = PHYSICS.brakeForce / PHYSICS.mass;
                const wheelSpeed = Math.abs(carState.speed);
                
                if (decel > PHYSICS.absThreshold && wheelSpeed > 1 && keys.space) {
                    carState.isABSActive = true;
                    brakeForce = PHYSICS.brakeForce * (Math.sin(Date.now() / 40) > 0 ? 1 : 0.2);
                } else {
                    carState.isABSActive = false;
                    brakeForce = PHYSICS.brakeForce;
                }
                brakeForce *= Math.sign(carState.speed) || 1;
            } else {
                carState.isABSActive = false;
            }

            const netForce = tractionForce - dragForce - rollingForce - engineBrakeForce - brakeForce;
            const acceleration = netForce / PHYSICS.mass;

            carState.speed += acceleration * dt;
            
            if (Math.abs(carState.speed) < 0.05 && carState.throttle === 0) {
                carState.speed = 0;
            }

            carState.distance += carState.speed * dt;

            // Calculate theoretical max speed for current gear to validate RPM
            // Speed (m/s) = (RPM * 2π * wheelRadius) / (60 * gearRatio * finalDrive)
            if (carState.gear > 0) {
                const wheelRPM = (carState.speed / (2 * Math.PI * PHYSICS.wheelRadius)) * 60;
                carState.rpm = Math.max(PHYSICS.idleRPM, wheelRPM * totalRatio);
                
                // Add some RPM for throttle input (clutch slip simulation)
                if (carState.throttle > 0 && carState.speed < 5) {
                    carState.rpm += carState.throttle * 300;
                }
            } else {
                carState.rpm = PHYSICS.idleRPM + (carState.throttle * (PHYSICS.maxRPM - PHYSICS.idleRPM));
            }
            
            carState.rpm = Math.min(carState.rpm, PHYSICS.maxRPM);

            // Weight transfer
            const accelG = acceleration / 9.81;
            const weightTransfer = Math.max(-60, Math.min(60, accelG * 30));
            
            carState.suspensionCompression.front = Math.max(0, weightTransfer * PHYSICS.suspensionStiffness);
            carState.suspensionCompression.rear = Math.max(0, -weightTransfer * PHYSICS.suspensionStiffness);
            carState.bodyPitch = weightTransfer * 0.002;

            carState.wheelRotation += (carState.speed / PHYSICS.wheelRadius) * dt;

            updateHUD(acceleration, dragForce, weightTransfer);
        }

        function shiftUp() {
            if (carState.gear < 6 && carState.shiftTimer <= 0) {
                carState.shiftTimer = 0.25; // Slightly longer shift
                carState.gear++;
                // RPM drops based on gear ratio change
                const ratioDiff = PHYSICS.gearRatios[carState.gear] / PHYSICS.gearRatios[carState.gear - 1];
                carState.rpm = Math.max(PHYSICS.idleRPM, carState.rpm * ratioDiff);
            }
        }

        function shiftDown() {
            if (carState.gear > 1 && carState.shiftTimer <= 0) {
                carState.shiftTimer = 0.25;
                carState.gear--;
                const ratioDiff = PHYSICS.gearRatios[carState.gear] / PHYSICS.gearRatios[carState.gear + 1];
                carState.rpm = Math.min(PHYSICS.maxRPM, carState.rpm * ratioDiff);
            }
        }

        function updateHUD(accel, drag, weightTransfer) {
            const speedKmh = Math.abs(carState.speed * 3.6);
            
            // Speedometer 0-200 km/h (realistic max now)
            const maxSpeed = 200;
            const clampedSpeed = Math.min(speedKmh, maxSpeed);
            const angle = -135 + (clampedSpeed / maxSpeed) * 270;
            document.getElementById('speedNeedle').style.transform = `translateX(-50%) rotate(${angle}deg)`;
            document.getElementById('speedDisplay').textContent = Math.floor(speedKmh);

            // RPM bar
            const rpmPercent = (carState.rpm / PHYSICS.maxRPM) * 100;
            const rpmBar = document.getElementById('rpmBar');
            rpmBar.style.width = rpmPercent + '%';
            
            if (carState.rpm > PHYSICS.redline) {
                rpmBar.parentElement.classList.add('shaking');
            } else {
                rpmBar.parentElement.classList.remove('shaking');
            }

            // Shift lights - come on closer to redline
            const lightStart = PHYSICS.redline - 800;
            for(let i = 0; i < 5; i++) {
                const threshold = lightStart + (i * 160);
                document.getElementById('sl' + (i+1)).classList.toggle('on', carState.rpm > threshold);
            }

            document.getElementById('gearDisplay').textContent = carState.gear === 0 ? 'N' : carState.gear;
            document.getElementById('rpmDisplay').textContent = Math.floor(carState.rpm);
            document.getElementById('gearRatio').textContent = PHYSICS.gearRatios[carState.gear].toFixed(2);
            document.getElementById('torqueVal').textContent = Math.floor(PHYSICS.maxTorque * (carState.rpm/PHYSICS.torquePeakRPM > 1 ? 0.8 : (carState.rpm/PHYSICS.torquePeakRPM)));
            document.getElementById('dragForce').textContent = Math.floor(drag);
            document.getElementById('weightTransfer').textContent = Math.floor(weightTransfer);
            
            const absEl = document.getElementById('absStatus');
            absEl.textContent = carState.isABSActive ? 'ACTIVE' : 'OFF';
            absEl.className = carState.isABSActive ? 'text-yellow-400 font-bold' : 'text-gray-500';
        }

        function updateVisuals() {
            wheels.forEach((wheel, idx) => {
                wheel.children.forEach(child => {
                    if (child.geometry.type === 'CylinderGeometry') {
                        child.rotation.x = carState.wheelRotation;
                    }
                });
                
                if (idx < 2) {
                    wheel.rotation.y = carState.steering * 0.4;
                }
            });

            steeringWheel.rotation.z = -carState.steering * 2;

            const baseHeight = 0.8;
            const pitchOffset = carState.bodyPitch;
            chassis.position.y = baseHeight + pitchOffset + Math.sin(Date.now()/300) * 0.002;
            chassis.rotation.x = carState.bodyPitch;
            chassis.rotation.z = -carState.steering * carState.speed * 0.02;

            // Camera follows car
            const speedFactor = Math.min(carState.speed * 0.1, 2);
            const targetCamPos = new THREE.Vector3(
                carGroup.position.x + 6 + speedFactor,
                carGroup.position.y + 4,
                carGroup.position.z + 8 + speedFactor
            );
            camera.position.lerp(targetCamPos, 0.05);
            controls.target.lerp(new THREE.Vector3(
                carGroup.position.x,
                carGroup.position.y + 0.5,
                carGroup.position.z
            ), 0.1);
            controls.update();
        }

        function animate(time) {
            requestAnimationFrame(animate);
            
            const dt = Math.min((time - lastTime) / 1000, 0.1) || 0.016;
            lastTime = time;

            updatePhysics(dt);
            updateVisuals();
            
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
