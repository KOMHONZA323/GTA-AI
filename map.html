<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GTA Style Map & Driving Sim</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 0; }
        
        /* UI Overlay (Map Generator) */
        #ui-layer {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 8px;
            color: white;
            border: 1px solid #444;
            width: 250px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            z-index: 20;
            display: none; /* Hidden by default for driving experience, toggle with key? */
        }
        /* Show UI on hover or key press? For now let's keep it visible but maybe smaller? Or let's keep it as is but ensure HUD is on top. */
        #ui-layer { display: block; }

        h2 { margin: 0 0 15px 0; font-size: 18px; color: #fbbf24; text-transform: uppercase; letter-spacing: 1px; }
        
        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-size: 14px; color: #ccc; }
        
        button {
            width: 100%;
            padding: 10px;
            margin-bottom: 8px;
            background: #333;
            border: 1px solid #555;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
            text-align: left;
            border-radius: 4px;
        }

        button:hover { background: #444; border-color: #fbbf24; }
        button.active { background: #fbbf24; color: #111; border-color: #fbbf24; }
        
        .btn-group { display: flex; gap: 5px; }
        .btn-group button { text-align: center; margin-bottom: 0; }

        .legend { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 15px; font-size: 12px; }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .dot { width: 10px; height: 10px; border-radius: 50%; }

        #minimap-ui {
            position: absolute;
            bottom: 30px;
            left: 30px;
            display: none;
            pointer-events: none;
            z-index: 20;
        }
        .wanted-stars {
            color: white;
            font-size: 24px;
            display: flex;
            gap: 5px;
            text-shadow: 0 0 5px black;
        }
        .star { color: #555; }
        .star.active { color: white; }

        #toast {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #fbbf24;
            color: #111;
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            z-index: 1000;
        }

        /* HUD Styles from car.html */
        .hud-panel {
            background: rgba(0, 20, 40, 0.9);
            border: 2px solid #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
            color: #00ff88;
        }

        .rpm-bar {
            background: linear-gradient(90deg, #00ff88 0%, #ffff00 70%, #ff0000 100%);
            height: 100%;
            transition: width 0.05s linear;
        }

        .gear-display {
            font-size: 4rem;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
        }

        .analog-gauge {
            position: relative;
            width: 180px;
            height: 180px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #1a1a2e, #0a0a0a);
            border: 4px solid #333;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.8), 0 0 20px rgba(0,0,0,0.5);
        }

        .gauge-needle {
            position: absolute;
            bottom: 50%;
            left: 50%;
            width: 4px;
            height: 70px;
            background: #ff0000;
            transform-origin: bottom center;
            transform: translateX(-50%) rotate(-135deg);
            transition: transform 0.05s linear;
            box-shadow: 0 0 10px rgba(255,0,0,0.8);
            border-radius: 2px;
        }

        .gauge-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 16px;
            height: 16px;
            background: #333;
            border-radius: 50%;
            border: 2px solid #666;
        }

        .speed-text {
            position: absolute;
            bottom: 25%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 2rem;
            font-weight: bold;
            color: #fff;
        }

        .kmh-label {
            position: absolute;
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7rem;
            color: #666;
        }

        .control-key {
            display: inline-block;
            padding: 8px 16px;
            margin: 4px;
            background: #222;
            border: 2px solid #444;
            border-radius: 8px;
            color: #fff;
            font-weight: bold;
            box-shadow: 0 4px 0 #000;
            cursor: pointer;
            user-select: none;
        }

        .control-key.active {
            background: #00ff88;
            color: #000;
            border-color: #00ff88;
            box-shadow: 0 2px 0 #004422;
            transform: translateY(2px);
        }

        .telemetry {
            font-size: 0.8rem;
            line-height: 1.4;
        }

        .redline { color: #ff0000; text-shadow: 0 0 10px rgba(255,0,0,0.8); }

        .shift-light {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #333;
            display: inline-block;
            margin: 0 2px;
            transition: all 0.1s;
            border: 1px solid #555;
        }
        .shift-light.on {
            background: #ff0000;
            box-shadow: 0 0 15px #ff0000, 0 0 30px #ff0000;
            border-color: #ff6666;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            75% { transform: translateX(2px); }
        }
        .shaking { animation: shake 0.1s infinite; }

        .light-btn {
            transition: all 0.3s;
        }
        .light-btn.on {
            background: #ffff00;
            color: #000;
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.6);
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    <div id="toast">Map Saved!</div>

    <!-- Map UI Overlay -->
    <div id="ui-layer">
        <h2>Map Architecture</h2>
        
        <div class="control-group">
            <label>Map Data:</label>
            <div class="btn-group">
                <button onclick="saveCity()">Save</button>
                <button onclick="loadCity()">Load</button>
                <button onclick="resetCity()">New</button>
            </div>
        </div>

        <div class="control-group">
            <label>Development Stage:</label>
            <button id="btn-stage1" onclick="setStage(1)">Stage 1: Grid & Data</button>
            <button id="btn-stage2" onclick="setStage(2)">Stage 2: Geometry Blockout</button>
            <button id="btn-stage3" onclick="setStage(3)">Stage 3: GTA Style Polish</button>
            <button id="btn-stage4" class="active" onclick="setStage(4)">Stage 4: Textured Detail</button>
        </div>

        <div class="control-group">
            <label>Controls:</label>
            <div style="font-size: 12px; color: #888;">
                WASD: Drive<br>
                Space: Brake<br>
                Shift/Ctrl: Gear Up/Down
            </div>
        </div>
        
        <div id="legend-container" class="legend">
            <!-- Populated by JS -->
        </div>
    </div>

    <div id="minimap-ui">
        <div class="wanted-stars">
            <span class="star active">★</span>
            <span class="star active">★</span>
            <span class="star">★</span>
            <span class="star">★</span>
            <span class="star">★</span>
        </div>
        <div style="color:white; font-size: 14px; font-weight: bold; margin-top:5px; text-shadow: 1px 1px 0 #000;">
            DOWNTOWN
        </div>
    </div>

    <!-- HUD Interface -->
    <div class="absolute top-0 left-0 w-full h-full pointer-events-none z-10 flex flex-col justify-between p-6">

        <!-- Top Bar -->
        <div class="flex justify-between items-start">
            <div class="hud-panel rounded-xl p-4 pointer-events-auto">
                <h1 class="text-xl font-bold mb-2 tracking-wider">PHYSICS SIMULATION</h1>
                <div class="telemetry text-xs space-y-1">
                    <div>GEAR RATIO: <span id="gearRatio">0.00</span></div>
                    <div>TORQUE: <span id="torqueVal">0</span> Nm</div>
                    <div>DRAG FORCE: <span id="dragForce">0</span> N</div>
                    <div>WEIGHT TRANSFER: <span id="weightTransfer">0</span>%</div>
                    <div>ABS STATUS: <span id="absStatus" class="text-gray-500">OFF</span></div>
                </div>
            </div>

            <div class="hud-panel rounded-xl p-4 pointer-events-auto flex flex-col items-center gap-2">
                <div class="text-xs tracking-widest mb-1">SHIFT LIGHTS</div>
                <div class="flex justify-center gap-1">
                    <div class="shift-light" id="sl1"></div>
                    <div class="shift-light" id="sl2"></div>
                    <div class="shift-light" id="sl3"></div>
                    <div class="shift-light" id="sl4"></div>
                    <div class="shift-light" id="sl5"></div>
                </div>
                <button id="lightBtn" onclick="toggleLights()" class="light-btn mt-2 px-4 py-2 bg-gray-800 border border-gray-600 rounded text-xs font-bold pointer-events-auto">
                    LIGHTS: ON
                </button>
            </div>
        </div>

        <!-- Middle Left - Speedometer -->
        <div class="absolute top-1/2 left-6 transform -translate-y-1/2 pointer-events-none">
            <div class="hud-panel rounded-2xl p-4 flex flex-col items-center">
                <div class="text-xs tracking-widest mb-2 text-gray-400">SPEED</div>
                <div class="analog-gauge">
                    <div class="gauge-needle" id="speedNeedle"></div>
                    <div class="gauge-center"></div>
                    <div class="speed-text"><span id="speedDisplay">0</span></div>
                    <div class="kmh-label">KM/H</div>
                </div>
            </div>
        </div>

        <!-- Bottom Controls -->
        <div class="flex justify-between items-end">
            <div class="hud-panel rounded-xl p-6 pointer-events-auto">
                <div class="flex items-center gap-4 mb-4">
                    <div class="gear-display" id="gearDisplay">1</div>
                    <div>
                        <div class="text-xs text-gray-400">RPM</div>
                        <div class="text-2xl font-bold" id="rpmDisplay">800</div>
                    </div>
                </div>

                <div class="w-64 h-4 bg-gray-800 rounded-full overflow-hidden border border-gray-600">
                    <div class="rpm-bar" id="rpmBar" style="width: 8%"></div>
                </div>
                <div class="flex justify-between text-xs mt-1">
                    <span>0</span>
                    <span id="redlineStart" class="redline">6000</span>
                    <span>8000</span>
                </div>
            </div>

            <div class="hud-panel rounded-xl p-4 pointer-events-auto">
                <div class="text-xs mb-3 tracking-widest text-center">CONTROLS</div>
                <div class="flex flex-col gap-2 items-center">
                    <div class="control-key" id="keyW">W</div>
                    <div class="flex gap-2">
                        <div class="control-key" id="keyA">A</div>
                        <div class="control-key" id="keyS">S</div>
                        <div class="control-key" id="keyD">D</div>
                    </div>
                    <div class="text-xs text-gray-400 mt-2">SPACE: BRAKE | SHIFT: UP | CTRL: DOWN</div>
                </div>
            </div>
        </div>
    </div>

<script>
    console.log("Map script starting...");
    // --- MAP CONFIGURATION ---
    const CONFIG = {
        gridSize: 80, 
        cellSize: 10,
        buildingHeightScale: 3,
        elevationHeight: 15,
        bridgeHeight: 3,
        colors: {
            water: 0x99B3CC,
            grass: 0xB8D9A9,
            road: 0xCCCCCC, 
            path: 0xDDDDDD, 
            highway: 0x555555, 
            carpark: 0x555555, 
            carparkLine: 0xFFFFFF,
            building: 0xE0E0E0,
            background: 0x88aad6 
        },
        stage1Colors: {
            grid: 0x333333,
            bg: 0x111111
        }
    };

    // --- CAR PHYSICS CONFIGURATION ---
    const PHYSICS = {
        maxRPM: 8000,
        idleRPM: 800,
        redline: 6000,
        maxTorque: 320,
        torquePeakRPM: 3500,
        gearRatios: [0, 4.2, 2.5, 1.6, 1.0, 0.75, 0.60],
        finalDrive: 4.1,
        wheelRadius: 0.35,
        mass: 1400,
        dragCoefficient: 0.32,
        frontalArea: 2.3,
        airDensity: 1.225,
        rollingResistance: 0.018,
        brakeForce: 10000,
        absThreshold: 5,
        suspensionStiffness: 0.3,
        suspensionDamping: 0.8
    };

    var scene, camera, renderer, controls;
    var mapGroup = new THREE.Group();
    var iconGroup = new THREE.Group();
    var cityData = [];
    var currentStage = 4;
    var buildingMaterials = [];
    var roadMaterials = {};

    // Car Globals - Using var for global access
    var carGroup, chassis, wheels = [], steeringWheel;
    var carState = {
        speed: 0,
        rpm: PHYSICS.idleRPM,
        gear: 1,
        throttle: 0,
        brake: 0,
        clutch: 0,
        steering: 0,
        distance: 0,
        wheelRotation: 0,
        engineAngularVel: 0,
        isABSActive: false,
        shiftTimer: 0,
        suspensionCompression: { front: 0, rear: 0 },
        bodyPitch: 0,
        bodyRoll: 0,
        y: 0
    };
    var keys = { w: false, a: false, s: false, d: false, space: false, shift: false, ctrl: false };
    var lightsOn = true;
    var headLightObjects = [];
    var tailLightObjects = [];
    var lastTime = 0;

    // --- ASSET GENERATION ---
    function createTexture(type) {
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        
        if (type === 'player') {
            // Player sprite texture (keep for minimap if needed, or remove)
            ctx.translate(32, 32);
            ctx.beginPath();
            ctx.moveTo(0, -24);
            ctx.lineTo(20, 24);
            ctx.lineTo(0, 16);
            ctx.lineTo(-20, 24);
            ctx.closePath();
            ctx.fillStyle = '#ffffff';
            ctx.fill();
            ctx.lineWidth = 4;
            ctx.strokeStyle = '#000000';
            ctx.stroke();
        } else if (type === 'home') {
            ctx.fillStyle = '#4ADE80'; 
            ctx.fillRect(10, 24, 44, 30);
            ctx.beginPath();
            ctx.moveTo(32, 10);
            ctx.lineTo(58, 24);
            ctx.lineTo(6, 24);
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.strokeRect(10, 24, 44, 30);
        } else if (type === 'mission') {
            ctx.fillStyle = '#FBBF24'; 
            ctx.beginPath();
            ctx.arc(32, 32, 28, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'black';
            ctx.font = 'bold 36px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('M', 32, 34);
        }

        const tex = new THREE.CanvasTexture(canvas);
        tex.minFilter = THREE.LinearFilter;
        return tex;
    }

    function createRoadTexture(type) {
        const canvas = document.createElement('canvas');
        canvas.width = 128; canvas.height = 128;
        const ctx = canvas.getContext('2d');

        ctx.fillStyle = '#444444';
        ctx.fillRect(0,0,128,128);

        for(let i=0; i<400; i++) {
            ctx.fillStyle = Math.random() > 0.5 ? '#555' : '#333';
            ctx.fillRect(Math.random()*128, Math.random()*128, 2, 2);
        }

        if (type === 'highway') {
            ctx.fillStyle = '#EBC934'; // Yellow (Inner)
            ctx.fillRect(0, 0, 128, 4); 
            ctx.fillStyle = '#FFFFFF'; // White (Outer)
            ctx.fillRect(0, 124, 128, 4); 
            ctx.fillStyle = '#FFFFFF';
            for(let i=0; i<128; i+=16) {
                ctx.fillRect(i, 62, 12, 4); 
            }
        } else if (type === 'horizontal') {
            ctx.fillStyle = '#EBC934'; 
            ctx.fillRect(0, 60, 128, 3);
            ctx.fillRect(0, 65, 128, 3);
            ctx.fillStyle = '#FFFFFF'; 
            ctx.fillRect(0, 10, 128, 2);
            ctx.fillRect(0, 116, 128, 2);
        } else if (type === 'vertical') {
            ctx.fillStyle = '#EBC934';
            ctx.fillRect(60, 0, 3, 128);
            ctx.fillRect(65, 0, 3, 128);
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(10, 0, 2, 128);
            ctx.fillRect(116, 0, 2, 128);
        } else if (type === 'intersection') {
            ctx.fillStyle = '#4a4a4a';
            ctx.fillRect(10, 10, 108, 108);
        }

        const tex = new THREE.CanvasTexture(canvas);
        tex.magFilter = THREE.NearestFilter;
        tex.minFilter = THREE.LinearMipMapLinearFilter;
        return tex;
    }

    function createBuildingTexture(style) {
        const canvas = document.createElement('canvas');
        canvas.width = 128; canvas.height = 128;
        const ctx = canvas.getContext('2d');

        if (style === 'office') {
            ctx.fillStyle = '#88ccff'; 
            ctx.fillRect(0,0,128,128);
            ctx.fillStyle = '#5599cc'; 
            for(let i=0; i<4; i++) {
                for(let j=0; j<8; j++) {
                    ctx.fillRect(i*32 + 2, j*16 + 2, 28, 12);
                }
            }
        } else if (style === 'brick') {
            ctx.fillStyle = '#a05040';
            ctx.fillRect(0,0,128,128);
            ctx.fillStyle = '#402010'; 
            for(let i=0; i<4; i++) {
                for(let j=0; j<4; j++) {
                    ctx.fillRect(i*32 + 8, j*32 + 8, 16, 20);
                }
            }
        } else if (style === 'concrete') {
            ctx.fillStyle = '#999999';
            ctx.fillRect(0,0,128,128);
            ctx.strokeStyle = '#777777';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for(let j=0; j<128; j+=16) {
                ctx.moveTo(0, j); ctx.lineTo(128, j);
            }
            ctx.stroke();
            ctx.fillStyle = '#333';
            for(let i=0; i<8; i++) {
                 ctx.fillRect(Math.random()*100, Math.random()*100, 10, 5);
            }
        }

        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        tex.magFilter = THREE.NearestFilter; 
        return tex;
    }

    const textures = {
        player: createTexture('player'),
        home: createTexture('home'),
        mission: createTexture('mission')
    };

    function init() {
        console.log("Initializing...");
        const container = document.getElementById('canvas-container');
        if(!container) console.error("Canvas container missing!");

        buildingMaterials = [
            new THREE.MeshLambertMaterial({ map: createBuildingTexture('office') }),
            new THREE.MeshLambertMaterial({ map: createBuildingTexture('brick') }),
            new THREE.MeshLambertMaterial({ map: createBuildingTexture('concrete') })
        ];

        roadMaterials = {
            horizontal: new THREE.MeshLambertMaterial({ map: createRoadTexture('horizontal') }),
            vertical: new THREE.MeshLambertMaterial({ map: createRoadTexture('vertical') }),
            intersection: new THREE.MeshLambertMaterial({ map: createRoadTexture('intersection') }),
            highway: new THREE.MeshLambertMaterial({ map: createRoadTexture('highway') }),
            generic: new THREE.MeshLambertMaterial({ color: CONFIG.colors.road })
        };

        scene = new THREE.Scene();
        scene.background = new THREE.Color(CONFIG.colors.background);
        scene.fog = new THREE.Fog(CONFIG.colors.background, 200, 800);

        // Switch to PerspectiveCamera for Driving
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 2000);
        camera.position.set(0, 100, 100);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.enabled = false; // Disable orbit controls for driving mode initially

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(100, 300, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.left = -500;
        dirLight.shadow.camera.right = 500;
        dirLight.shadow.camera.top = 500;
        dirLight.shadow.camera.bottom = -500;
        scene.add(dirLight);

        // Load or Generate Map
        if(localStorage.getItem('gta_map_data')) {
            console.log("Loading city...");
            loadCity();
        } else {
            console.log("Generating city...");
            generateCityData();
            setStage(4); 
        }

        // Initialize Car
        console.log("Creating car...");
        createDetailedCar();
        setupInputs();

        // Position car at center
        carGroup.position.set(0, 10, 0);

        window.addEventListener('resize', onWindowResize, false);
        animate();
        console.log("Initialization complete.");
    }

    // --- CAR CREATION ---
    function createDetailedCar() {
        carGroup = new THREE.Group();
        window.carGroup = carGroup; // Explicitly expose to window for testing

        const carPaint = new THREE.MeshPhysicalMaterial({
            color: 0xcc0000,
            metalness: 0.6,
            roughness: 0.2,
            clearcoat: 1.0,
            clearcoatRoughness: 0.03
        });

        const blackTrim = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.5 });
        const glassMat = new THREE.MeshPhysicalMaterial({
            color: 0x111111,
            metalness: 0.9,
            roughness: 0.0,
            transparent: true,
            opacity: 0.6
        });

        const chassisGeom = new THREE.BoxGeometry(2, 0.6, 4.5);
        chassis = new THREE.Mesh(chassisGeom, carPaint);
        chassis.position.y = 0.8;
        chassis.castShadow = true;
        carGroup.add(chassis);

        const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.5, 2.3), carPaint);
        cabin.position.set(0, 1.35, -0.2);
        cabin.castShadow = true;
        carGroup.add(cabin);

        const windshield = new THREE.Mesh(new THREE.PlaneGeometry(1.6, 0.9), glassMat);
        windshield.position.set(0, 1.4, 0.96);
        windshield.rotation.x = -Math.PI / 3;
        carGroup.add(windshield);

        const rearWindow = new THREE.Mesh(new THREE.PlaneGeometry(1.6, 0.8), glassMat);
        rearWindow.position.set(0, 1.4, -1.36);
        rearWindow.rotation.x = Math.PI / 3;
        rearWindow.rotation.y = Math.PI;
        carGroup.add(rearWindow);

        const wheelPositions = [
            { x: 1.1, z: 1.4, name: 'FL' },
            { x: -1.1, z: 1.4, name: 'FR' },
            { x: 1.1, z: -1.4, name: 'RL' },
            { x: -1.1, z: -1.4, name: 'RR' }
        ];

        wheelPositions.forEach(pos => {
            const wheelGroup = new THREE.Group();

            const tire = new THREE.Mesh(
                new THREE.CylinderGeometry(0.35, 0.35, 0.28, 32),
                new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.9 })
            );
            tire.rotation.z = Math.PI / 2;
            tire.castShadow = true;
            wheelGroup.add(tire);

            const rim = new THREE.Mesh(
                new THREE.CylinderGeometry(0.22, 0.22, 0.29, 16),
                new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.9, roughness: 0.1 })
            );
            rim.rotation.z = Math.PI / 2;
            wheelGroup.add(rim);

            for(let i = 0; i < 5; i++) {
                const spoke = new THREE.Mesh(
                    new THREE.BoxGeometry(0.32, 0.06, 0.3),
                    new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.9 })
                );
                spoke.rotation.z = Math.PI / 2;
                spoke.rotation.x = (i / 5) * Math.PI * 2;
                wheelGroup.add(spoke);
            }

            wheelGroup.position.set(pos.x, 0.35, pos.z);
            wheels.push(wheelGroup);
            carGroup.add(wheelGroup);
        });

        steeringWheel = new THREE.Mesh(
            new THREE.TorusGeometry(0.18, 0.025, 8, 32),
            new THREE.MeshStandardMaterial({ color: 0x333333 })
        );
        steeringWheel.position.set(0, 1.15, 0.6);
        steeringWheel.rotation.x = -Math.PI / 3;
        carGroup.add(steeringWheel);

        const headlightGeom = new THREE.BoxGeometry(0.5, 0.2, 0.1);
        const headlightMat = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            emissive: 0xffffff,
            emissiveIntensity: 0.8
        });

        const hlLeft = new THREE.Mesh(headlightGeom, headlightMat);
        hlLeft.position.set(0.7, 0.75, 2.26);
        carGroup.add(hlLeft);
        headLightObjects.push(hlLeft);

        const hlRight = hlLeft.clone();
        hlRight.position.set(-0.7, 0.75, 2.26);
        carGroup.add(hlRight);
        headLightObjects.push(hlRight);

        const tailMat = new THREE.MeshStandardMaterial({
            color: 0xff0000,
            emissive: 0xff0000,
            emissiveIntensity: 0.8
        });
        const tlLeft = new THREE.Mesh(headlightGeom, tailMat);
        tlLeft.position.set(0.7, 0.8, -2.26);
        carGroup.add(tlLeft);
        tailLightObjects.push(tlLeft);

        const tlRight = tlLeft.clone();
        tlRight.position.set(-0.7, 0.8, -2.26);
        carGroup.add(tlRight);
        tailLightObjects.push(tlRight);

        // Spoiler
        const spoiler = new THREE.Mesh(new THREE.BoxGeometry(1.9, 0.08, 0.4), blackTrim);
        spoiler.position.set(0, 1.45, -2.1);
        carGroup.add(spoiler);

        // Exhaust
        const exhaust = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 0.3), new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.8 }));
        exhaust.rotation.z = Math.PI / 2;
        exhaust.position.set(0.5, 0.35, -2.3);
        carGroup.add(exhaust);
        const exhaust2 = exhaust.clone();
        exhaust2.position.set(-0.5, 0.35, -2.3);
        carGroup.add(exhaust2);

        scene.add(carGroup);
        setupLighting();
    }

    function setupLighting() {
        const leftBeam = new THREE.SpotLight(0xffffff, 3);
        leftBeam.position.set(0.7, 0.75, 2.3);
        leftBeam.target.position.set(0.7, 0, 30);
        leftBeam.angle = Math.PI / 5;
        leftBeam.penumbra = 0.2;
        leftBeam.distance = 50;
        leftBeam.castShadow = true;
        carGroup.add(leftBeam);
        carGroup.add(leftBeam.target);
        headLightObjects.push(leftBeam);

        const rightBeam = new THREE.SpotLight(0xffffff, 3);
        rightBeam.position.set(-0.7, 0.75, 2.3);
        rightBeam.target.position.set(-0.7, 0, 30);
        rightBeam.angle = Math.PI / 5;
        rightBeam.penumbra = 0.2;
        rightBeam.distance = 50;
        rightBeam.castShadow = true;
        carGroup.add(rightBeam);
        carGroup.add(rightBeam.target);
        headLightObjects.push(rightBeam);
    }

    window.toggleLights = function() {
        lightsOn = !lightsOn;
        const btn = document.getElementById('lightBtn');
        btn.textContent = lightsOn ? 'LIGHTS: ON' : 'LIGHTS: OFF';
        btn.classList.toggle('on', lightsOn);

        headLightObjects.forEach(obj => {
            if (obj.isMesh) {
                obj.material.emissiveIntensity = lightsOn ? 0.8 : 0.1;
            } else if (obj.isLight) {
                obj.intensity = lightsOn ? 3 : 0;
            }
        });

        tailLightObjects.forEach(obj => {
            obj.material.emissiveIntensity = lightsOn ? 0.8 : 0.2;
        });
    }

    function setupInputs() {
        window.addEventListener('keydown', (e) => {
            const code = e.code;
            if (code === 'KeyW' || code === 'ArrowUp') { keys.w = true; document.getElementById('keyW').classList.add('active'); }
            if (code === 'KeyS' || code === 'ArrowDown') { keys.s = true; document.getElementById('keyS').classList.add('active'); }
            if (code === 'KeyA' || code === 'ArrowLeft') { keys.a = true; document.getElementById('keyA').classList.add('active'); }
            if (code === 'KeyD' || code === 'ArrowRight') { keys.d = true; document.getElementById('keyD').classList.add('active'); }
            if (code === 'Space') keys.space = true;
            if (code === 'ShiftLeft' || code === 'ShiftRight') { keys.shift = true; if (carState.gear < 6) shiftUp(); }
            if (code === 'ControlLeft' || code === 'ControlRight') { keys.ctrl = true; if (carState.gear > 1) shiftDown(); }
        });

        window.addEventListener('keyup', (e) => {
            const code = e.code;
            if (code === 'KeyW' || code === 'ArrowUp') { keys.w = false; document.getElementById('keyW').classList.remove('active'); }
            if (code === 'KeyS' || code === 'ArrowDown') { keys.s = false; document.getElementById('keyS').classList.remove('active'); }
            if (code === 'KeyA' || code === 'ArrowLeft') { keys.a = false; document.getElementById('keyA').classList.remove('active'); }
            if (code === 'KeyD' || code === 'ArrowRight') { keys.d = false; document.getElementById('keyD').classList.remove('active'); }
            if (code === 'Space') keys.space = false;
            if (code === 'ShiftLeft' || code === 'ShiftRight') keys.shift = false;
            if (code === 'ControlLeft' || code === 'ControlRight') keys.ctrl = false;
        });
    }

    // --- PHYSICS & LOGIC ---

    function getGroundHeight(x, z) {
        const gridX = Math.round(x / CONFIG.cellSize + CONFIG.gridSize / 2);
        const gridZ = Math.round(z / CONFIG.cellSize + CONFIG.gridSize / 2);

        if (gridX >= 0 && gridX < CONFIG.gridSize && gridZ >= 0 && gridZ < CONFIG.gridSize) {
            const cell = cityData[gridX][gridZ];

            // Basic Building Collision Check
            if (cell.type === 'building') {
                return 'collision';
            }

            if (cell.isElevated) {
                if (cell.isRamp) {
                    const step = CONFIG.elevationHeight / 5;
                    return CONFIG.elevationHeight - (cell.rampLevel * step);
                } else if (cell.isBridgeRamp) {
                    // Approximate bridge ramp height
                    const targetH = cell.rampTargetHeight || CONFIG.bridgeHeight;
                    return targetH / 2; // Simplified
                } else if (cell.isBridge) {
                    return CONFIG.bridgeHeight;
                }
                return CONFIG.elevationHeight;
            }
            if (cell.isBridge) return CONFIG.bridgeHeight;

            return 0; // Ground level
        }
        return 0; // Default ground
    }

    function updatePhysics(dt) {
        if (carState.shiftTimer > 0) { carState.shiftTimer -= dt; carState.throttle = 0; }

        carState.throttle = keys.w ? 1 : 0;
        carState.brake = (keys.s || keys.space) ? 1 : 0;
        carState.clutch = keys.shift ? 1 : 0;

        const targetSteering = keys.a ? 0.6 : (keys.d ? -0.6 : 0);
        carState.steering += (targetSteering - carState.steering) * 8 * dt;

        let rpmRatio = carState.rpm / PHYSICS.torquePeakRPM;
        let torqueMultiplier;
        if (carState.rpm < PHYSICS.idleRPM) { torqueMultiplier = 0.1; }
        else if (carState.rpm < PHYSICS.torquePeakRPM) { torqueMultiplier = 0.4 + (0.6 * (carState.rpm - PHYSICS.idleRPM) / (PHYSICS.torquePeakRPM - PHYSICS.idleRPM)); }
        else { torqueMultiplier = 1.0 - ((carState.rpm - PHYSICS.torquePeakRPM) / (PHYSICS.maxRPM - PHYSICS.torquePeakRPM)) * 0.6; }
        if (carState.rpm > PHYSICS.redline) { torqueMultiplier *= Math.max(0.3, 1 - (carState.rpm - PHYSICS.redline) / 1000); }

        const currentTorque = PHYSICS.maxTorque * torqueMultiplier * carState.throttle;
        const currentGearRatio = PHYSICS.gearRatios[carState.gear];
        const totalRatio = currentGearRatio * PHYSICS.finalDrive;

        let tractionForce = 0;
        if (carState.gear > 0 && carState.clutch < 0.5) {
            tractionForce = currentTorque * totalRatio / PHYSICS.wheelRadius;
            const maxTraction = 8000;
            if (tractionForce > maxTraction) tractionForce = maxTraction;
        }

        const dragForce = 0.5 * PHYSICS.airDensity * PHYSICS.dragCoefficient * PHYSICS.frontalArea * (carState.speed * carState.speed);
        const rollingForce = PHYSICS.rollingResistance * PHYSICS.mass * 9.81;
        const engineBrakeForce = (carState.throttle === 0 && carState.gear > 0) ? (carState.rpm * 0.012) : 0;

        let brakeForce = 0;
        if (carState.brake > 0) {
            const decel = PHYSICS.brakeForce / PHYSICS.mass;
            if (decel > PHYSICS.absThreshold && Math.abs(carState.speed) > 1 && keys.space) {
                carState.isABSActive = true;
                brakeForce = PHYSICS.brakeForce * (Math.sin(Date.now() / 40) > 0 ? 1 : 0.2);
            } else {
                carState.isABSActive = false;
                brakeForce = PHYSICS.brakeForce;
            }
            brakeForce *= Math.sign(carState.speed) || 1;
        } else {
            carState.isABSActive = false;
        }

        const netForce = tractionForce - dragForce - rollingForce - engineBrakeForce - brakeForce;
        const acceleration = netForce / PHYSICS.mass;

        carState.speed += acceleration * dt;
        if (Math.abs(carState.speed) < 0.05 && carState.throttle === 0) { carState.speed = 0; }

        carState.distance += carState.speed * dt;

        if (carState.gear > 0) {
            const wheelRPM = (carState.speed / (2 * Math.PI * PHYSICS.wheelRadius)) * 60;
            carState.rpm = Math.max(PHYSICS.idleRPM, wheelRPM * totalRatio);
            if (carState.throttle > 0 && carState.speed < 5) { carState.rpm += carState.throttle * 300; }
        } else {
            carState.rpm = PHYSICS.idleRPM + (carState.throttle * (PHYSICS.maxRPM - PHYSICS.idleRPM));
        }
        carState.rpm = Math.min(carState.rpm, PHYSICS.maxRPM);

        const accelG = acceleration / 9.81;
        const weightTransfer = Math.max(-60, Math.min(60, accelG * 30));
        carState.suspensionCompression.front = Math.max(0, weightTransfer * PHYSICS.suspensionStiffness);
        carState.suspensionCompression.rear = Math.max(0, -weightTransfer * PHYSICS.suspensionStiffness);
        carState.bodyPitch = weightTransfer * 0.002;
        carState.wheelRotation += (carState.speed / PHYSICS.wheelRadius) * dt;

        // --- POSITION UPDATE ---
        // Calculate new position based on speed and direction (car rotation)
        const moveStep = carState.speed * dt;
        const carRot = carGroup.rotation.y;

        const nextX = carGroup.position.x + Math.sin(carRot) * moveStep;
        const nextZ = carGroup.position.z + Math.cos(carRot) * moveStep;

        // Terrain / Collision Check
        const groundHeight = getGroundHeight(nextX, nextZ);

        if (groundHeight === 'collision') {
            // Stop car or bounce
            carState.speed = -carState.speed * 0.5; // Bounce back
        } else {
            carGroup.position.x = nextX;
            carGroup.position.z = nextZ;

            // Smooth vertical transition
            const targetY = groundHeight;
            carGroup.position.y += (targetY - carGroup.position.y) * 0.1;
        }

        // Steering
        carGroup.rotation.y += carState.steering * carState.speed * 0.02 * dt;

        updateHUD(acceleration, dragForce, weightTransfer);
    }

    function shiftUp() {
        if (carState.gear < 6 && carState.shiftTimer <= 0) {
            carState.shiftTimer = 0.25; carState.gear++;
            const ratioDiff = PHYSICS.gearRatios[carState.gear] / PHYSICS.gearRatios[carState.gear - 1];
            carState.rpm = Math.max(PHYSICS.idleRPM, carState.rpm * ratioDiff);
        }
    }

    function shiftDown() {
        if (carState.gear > 1 && carState.shiftTimer <= 0) {
            carState.shiftTimer = 0.25; carState.gear--;
            const ratioDiff = PHYSICS.gearRatios[carState.gear] / PHYSICS.gearRatios[carState.gear + 1];
            carState.rpm = Math.min(PHYSICS.maxRPM, carState.rpm * ratioDiff);
        }
    }

    function updateHUD(accel, drag, weightTransfer) {
        try {
            const speedKmh = Math.abs(carState.speed * 3.6);
            const maxSpeed = 200;
            const clampedSpeed = Math.min(speedKmh, maxSpeed);
            const angle = -135 + (clampedSpeed / maxSpeed) * 270;
            const speedNeedle = document.getElementById('speedNeedle');
            if(speedNeedle) speedNeedle.style.transform = `translateX(-50%) rotate(${angle}deg)`;

            const speedDisplay = document.getElementById('speedDisplay');
            if(speedDisplay) speedDisplay.textContent = Math.floor(speedKmh);

            const rpmPercent = (carState.rpm / PHYSICS.maxRPM) * 100;
            const rpmBar = document.getElementById('rpmBar');
            if(rpmBar) {
                rpmBar.style.width = rpmPercent + '%';
                if (carState.rpm > PHYSICS.redline) rpmBar.parentElement.classList.add('shaking');
                else rpmBar.parentElement.classList.remove('shaking');
            }

            const lightStart = PHYSICS.redline - 800;
            for(let i = 0; i < 5; i++) {
                const threshold = lightStart + (i * 160);
                const el = document.getElementById('sl' + (i+1));
                if(el) el.classList.toggle('on', carState.rpm > threshold);
            }

            const gd = document.getElementById('gearDisplay'); if(gd) gd.textContent = carState.gear === 0 ? 'N' : carState.gear;
            const rd = document.getElementById('rpmDisplay'); if(rd) rd.textContent = Math.floor(carState.rpm);
            const gr = document.getElementById('gearRatio'); if(gr) gr.textContent = PHYSICS.gearRatios[carState.gear].toFixed(2);
            const tv = document.getElementById('torqueVal'); if(tv) tv.textContent = Math.floor(PHYSICS.maxTorque * (carState.rpm/PHYSICS.torquePeakRPM > 1 ? 0.8 : (carState.rpm/PHYSICS.torquePeakRPM)));
            const df = document.getElementById('dragForce'); if(df) df.textContent = Math.floor(drag);
            const wt = document.getElementById('weightTransfer'); if(wt) wt.textContent = Math.floor(weightTransfer);

            const absEl = document.getElementById('absStatus');
            if(absEl) {
                absEl.textContent = carState.isABSActive ? 'ACTIVE' : 'OFF';
                absEl.className = carState.isABSActive ? 'text-yellow-400 font-bold' : 'text-gray-500';
            }
        } catch(e) {
            console.error("HUD Error:", e);
        }
    }

    function updateVisuals() {
        if(!carGroup || !chassis) return;

        wheels.forEach((wheel, idx) => {
            wheel.children.forEach(child => {
                if (child.geometry.type === 'CylinderGeometry') { child.rotation.x = carState.wheelRotation; }
            });
            if (idx < 2) { wheel.rotation.y = carState.steering * 0.4; }
        });

        if(steeringWheel) steeringWheel.rotation.z = -carState.steering * 2;

        const baseHeight = 0.8;
        chassis.position.y = baseHeight + carState.bodyPitch + Math.sin(Date.now()/300) * 0.002;
        chassis.rotation.x = carState.bodyPitch;
        chassis.rotation.z = -carState.steering * carState.speed * 0.02;

        // Camera Follow
        const offset = new THREE.Vector3(0, 15, -25); // Behind and above
        offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), carGroup.rotation.y);

        const targetPos = carGroup.position.clone().add(offset);
        camera.position.lerp(targetPos, 0.1);

        const lookAtPos = carGroup.position.clone().add(new THREE.Vector3(0, 2, 0));
        camera.lookAt(lookAtPos);
    }

    // --- STORAGE FUNCTIONS ---
    function showToast(msg) {
        const t = document.getElementById('toast');
        if(!t) return;
        t.innerText = msg;
        t.style.opacity = '1';
        setTimeout(() => t.style.opacity = '0', 2000);
    }

    window.saveCity = function() {
        try {
            const dataStr = JSON.stringify(cityData);
            localStorage.setItem('gta_map_data', dataStr);
            showToast("Map Saved!");
        } catch(e) { console.error(e); showToast("Error Saving Map"); }
    };

    window.loadCity = function() {
        const dataStr = localStorage.getItem('gta_map_data');
        if(!dataStr) { showToast("No Saved Map Found"); return; }
        cityData = JSON.parse(dataStr);
        setStage(currentStage);
        showToast("Map Loaded!");
    };

    window.resetCity = function() {
        generateCityData();
        setStage(currentStage);
        showToast("New Map Generated");
    };

    // --- MAP GENERATION LOGIC (FROM ORIGINAL MAP.HTML) ---
    function generateCityData() {
        cityData = [];
        const size = CONFIG.gridSize;
        const center = Math.floor(size / 2);

        // 1. Initialize Base
        for(let x=0; x<size; x++) {
            cityData[x] = [];
            for(let z=0; z<size; z++) {
                cityData[x][z] = { type: 'grass', height: 0, isElevated: false, rampLevel: 0, isWater: false };
            }
        }

        // 2. Generate River
        for(let x=0; x<size; x++) {
            const z = Math.floor(center + Math.sin(x * 0.1) * (size * 0.35));
            const width = Math.floor(Math.random() * 2) + 4; 
            for(let w=-width; w<=width; w++) {
                if(z+w >= 0 && z+w < size) {
                     cityData[x][z+w] = { type: 'water', height: 0, isWater: true }; 
                }
            }
        }

        // 2.5 Landfill for Main Street
        for(let z = 0; z < size; z++) {
            for(let x = center - 2; x <= center + 3; x++) {
                if(x >= 0 && x < size) {
                    cityData[x][z].type = 'grass';
                    cityData[x][z].isWater = false;
                }
            }
        }

        function getNeighborType(x, z) {
            if(x<0||x>=size||z<0||z>=size) return null;
            return cityData[x][z].type;
        }

        function setMedian(x, z) {
            if(x < 0 || x >= size || z < 0 || z >= size) return;
            cityData[x][z] = { type: 'median', height: 0, isElevated: true, rampLevel: 0 };
        }

        function setRoad(x, z, isHighway, rampLevel = 0, isHorizontal = false, highwaySide = 'none', highwaySection = '') {
            if(x < 0 || x >= size || z < 0 || z >= size) return;
            const wasWater = cityData[x][z].isWater;
            
            if (cityData[x][z].isHighway && !isHighway) {
                cityData[x][z].hasUnderpass = true;
                return;
            }

            cityData[x][z] = { 
                type: 'road', 
                height: 0, 
                isHighway: isHighway,
                highwaySide: highwaySide, 
                highwaySection: highwaySection, 
                isElevated: false, 
                isBridge: false,
                isRamp: false,
                rampLevel: rampLevel, 
                isHorizontal: isHorizontal,
                isBridgeRamp: false,
                isIntersection: false,
                stopLineDir: null,
                isWaterCrossing: wasWater,
                hasUnderpass: false,
                rampTargetHeight: 0
            };
        }

        // 3. Ring Road Highway
        const margin = 10;
        const min = margin;
        const max = size - margin;
        
        for(let i=min; i<=max; i++) {
            setRoad(i, min, true, 0, true, 'outer', 'top');      
            setRoad(i, max, true, 0, true, 'outer', 'bottom');      
            setRoad(min, i, true, 0, false, 'outer', 'left');     
            setRoad(max, i, true, 0, false, 'outer', 'right');     
        }
        for(let i=min+1; i<=max-1; i++) {
            setMedian(i, min+1);
            setMedian(i, max-1);
            setMedian(min+1, i);
            setMedian(max-1, i);
        }
        for(let i=min+2; i<=max-2; i++) {
            setRoad(i, min+2, true, 0, true, 'inner', 'top');
            setRoad(i, max-2, true, 0, true, 'inner', 'bottom');
            setRoad(min+2, i, true, 0, false, 'inner', 'left');
            setRoad(max-2, i, true, 0, false, 'inner', 'right');
        }

        cityData[min][min].isIntersection = true;
        cityData[max][min].isIntersection = true;
        cityData[min][max].isIntersection = true;
        cityData[max][max].isIntersection = true;
        cityData[min+2][min+2].isIntersection = true;
        cityData[max-2][min+2].isIntersection = true;
        cityData[min+2][max-2].isIntersection = true;
        cityData[max-2][max-2].isIntersection = true;

        function createInterchange(startX, startZ, dirX, dirZ, isHorizontal) {
            for(let i=1; i<=4; i++) {
                const rx = startX + (dirX * i);
                const rz = startZ + (dirZ * i);
                setRoad(rx, rz, false, i, isHorizontal); 
            }
        }
        createInterchange(center, min + 2, 0, 1, false); 
        createInterchange(center, max - 2, 0, -1, false); 
        createInterchange(min + 2, center, 1, 0, true);
        createInterchange(max - 2, center, -1, 0, true);

        const innerMin = min + 7;
        const innerMax = max - 7;
        const blockSize = 14;

        for(let z = 0; z < size; z++) {
            setRoad(center, z, false, 0, false);      
            setRoad(center + 1, z, false, 0, false); 
        }

        for(let z = innerMin; z <= innerMax; z += blockSize) {
            for(let x = innerMin; x <= innerMax; x++) {
                setRoad(x, z, false, 0, true);
            }
        }
        for(let x = innerMin + blockSize; x < innerMax; x += blockSize) {
            if (x === center || x === center+1) continue; 
            for(let z = innerMin; z <= innerMax; z++) {
                setRoad(x, z, false, 0, false);
            }
        }

        const dirs = [{dx:1, dz:0}, {dx:-1, dz:0}, {dx:0, dz:1}, {dx:0, dz:-1}];

        for(let x=0; x<size; x++) {
            for(let z=0; z<size; z++) {
                const cell = cityData[x][z];
                if(cell.type === 'road' && cell.isHighway) {
                    if(cell.rampLevel === 0) cell.isElevated = true;
                    else cell.isRamp = true; 
                }
            }
        }

        for(let x=0; x<size; x++) {
            for(let z=0; z<size; z++) {
                const cell = cityData[x][z];
                if(cell.type === 'road' && !cell.isHighway && cell.isWaterCrossing) {
                    cell.isBridge = true;
                }
            }
        }

        for(let x=0; x<size; x++) {
            for(let z=0; z<size; z++) {
                const cell = cityData[x][z];
                if (cell.type === 'road' && !cell.isHighway) {
                    let connections = 0;
                    for(let d of dirs) {
                        const nx = x+d.dx; const nz = z+d.dz;
                        if(nx>=0 && nx<size && nz>=0 && nz<size) {
                            if(cityData[nx][nz].type === 'road') connections++;
                        }
                    }
                    if (connections > 2) cell.isIntersection = true;
                }
            }
        }

        for(let x=0; x<size; x++) {
            for(let z=0; z<size; z++) {
                const cell = cityData[x][z];
                if(cell.isIntersection && !cell.isBridge) {
                    let nextToBridge = false;
                    for(let d of dirs) {
                        const nx = x+d.dx; const nz = z+d.dz;
                        if(nx>=0 && nx<size && nz>=0 && nz<size) {
                            if(cityData[nx][nz].isBridge) {
                                nextToBridge = true; break;
                            }
                        }
                    }
                    if(nextToBridge) cell.isBridge = true; 
                }
            }
        }

        for(let x=0; x<size; x++) {
            for(let z=0; z<size; z++) {
                const cell = cityData[x][z];
                if (cell.type === 'road' && !cell.isHighway && !cell.isBridge) {
                     for(let d of dirs) {
                          const nx = x+d.dx; const nz = z+d.dz;
                          if(nx>=0 && nx<size && nz>=0 && nz<size) {
                              const neighbor = cityData[nx][nz];
                              let targetH = 0;
                              if (neighbor.isBridge) targetH = CONFIG.bridgeHeight;
                              else if (neighbor.isElevated) targetH = CONFIG.elevationHeight;
                              if (targetH > 0) {
                                  cell.isBridgeRamp = true;
                                  cell.rampDir = d;
                                  cell.rampTargetHeight = targetH;
                                  break; 
                              }
                          }
                      }
                }
            }
        }

        for(let x=0; x<size; x++) {
            for(let z=0; z<size; z++) {
                const cell = cityData[x][z];
                if (cell.type === 'road' && !cell.isHighway && !cell.isBridge && !cell.isBridgeRamp && !cell.isIntersection) {
                    for(let d of dirs) {
                        const nx = x+d.dx; const nz = z+d.dz;
                        if(nx>=0 && nx<size && nz>=0 && nz<size) {
                            const neighbor = cityData[nx][nz];
                            if (neighbor.isIntersection && !neighbor.isBridge) {
                                cell.stopLineDir = d;
                                break;
                            }
                        }
                    }
                }
            }
        }

        for(let x=innerMin; x<=innerMax; x++) { for(let z=innerMin; z<=innerMax; z++) { if(cityData[x][z].type === 'grass') { if (x % (blockSize/2) === 0 || z % (blockSize/2) === 0) { cityData[x][z] = { type: 'path', height: 0 }; } } } }

        for(let x=innerMin; x<=innerMax; x++) { for(let z=innerMin; z<=innerMax; z++) { if(cityData[x][z].type === 'grass') { const neighbors = [{dx:1, dz:0}, {dx:-1, dz:0}, {dx:0, dz:1}, {dx:0, dz:-1}]; let nearRoad = false; for(let n of neighbors) { let t = getNeighborType(x+n.dx, z+n.dz); if(t === 'road') nearRoad = true; } if(nearRoad && Math.random() < 0.08) { cityData[x][z] = { type: 'carpark', height: 0 }; } } } }

        for(let x=0; x<size; x++) { for(let z=0; z<size; z++) { if (x < min || x > max || z < min || z > max) { if (cityData[x][z].type !== 'water') cityData[x][z] = { type: 'grass', height: 0 }; continue; } if(cityData[x][z].type !== 'grass') continue; let hasAccess = false; const neighbors = [{dx:1, dz:0}, {dx:-1, dz:0}, {dx:0, dz:1}, {dx:0, dz:-1}]; for(let n of neighbors) { let nx = x + n.dx; let nz = z + n.dz; if(nx>=0 && nx<size && nz>=0 && nz<size) { const t = cityData[nx][nz].type; if(t === 'road' || t === 'path' || t === 'carpark') { hasAccess = true; break; } } } if(hasAccess) { const dist = Math.sqrt(Math.pow(x-center, 2) + Math.pow(z-center, 2)); const rand = Math.random(); let h = 0; let style = 1; if(dist < size * 0.15) { h = 15 + Math.random() * 30; style = 0; } else if (dist < size * 0.35) { h = 5 + Math.random() * 10; style = (rand > 0.5) ? 0 : 2; } else { h = 2 + Math.random() * 4; style = 1; } if (rand > 0.15) cityData[x][z] = { type: 'building', height: h, style: style }; } } }
    }

    function clearMap() {
        if(mapGroup) scene.remove(mapGroup);
        if(iconGroup) scene.remove(iconGroup);
        mapGroup = new THREE.Group();
        iconGroup = new THREE.Group();
        scene.add(mapGroup);
        scene.add(iconGroup);
    }

    function renderStage1() {
        scene.background = new THREE.Color(CONFIG.stage1Colors.bg);
        const size = CONFIG.gridSize * CONFIG.cellSize;
        mapGroup.add(new THREE.GridHelper(size, CONFIG.gridSize, 0x444444, 0x222222));
        document.getElementById('legend-container').innerHTML = `<div class="legend-item" style="color:white">Stage 1: Wireframe Data</div>`;
        document.getElementById('minimap-ui').style.display = 'none';
    }

    function renderStage2() {
        scene.background = new THREE.Color(0xdddddd); 
        document.getElementById('legend-container').innerHTML = `<div class="legend-item">Stage 2: Geometry Blockout</div>`;
        document.getElementById('minimap-ui').style.display = 'none';
    }

    function renderPolishStage(isTextured) {
        scene.background = new THREE.Color(CONFIG.colors.background);
        const groundSize = CONFIG.gridSize * CONFIG.cellSize;
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(groundSize, groundSize), new THREE.MeshLambertMaterial({ color: CONFIG.colors.grass }));
        ground.rotation.x = -Math.PI / 2; ground.position.y = -2; ground.receiveShadow = true; mapGroup.add(ground);

        const pillarGeo = new THREE.CylinderGeometry(2, 2, CONFIG.elevationHeight, 8);
        const pillarMat = new THREE.MeshLambertMaterial({ color: 0x444444 });
        const bridgePillarGeo = new THREE.CylinderGeometry(1.5, 1.5, 4, 8); 
        const stopLineMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
        const treeGeo = new THREE.ConeGeometry(2, 6, 8);
        const treeMat = new THREE.MeshLambertMaterial({ color: 0x2d5a27 });

        for(let x=0; x<CONFIG.gridSize; x++) {
            for(let z=0; z<CONFIG.gridSize; z++) {
                const cell = cityData[x][z];
                const posX = (x - CONFIG.gridSize/2) * CONFIG.cellSize;
                const posZ = (z - CONFIG.gridSize/2) * CONFIG.cellSize;

                if(cell.type === 'building') {
                    const h = cell.height * CONFIG.buildingHeightScale;
                    const w = CONFIG.cellSize * 0.85;
                    let mat = isTextured ? buildingMaterials[cell.style || 0] : new THREE.MeshLambertMaterial({ color: CONFIG.colors.building });
                    if(isTextured && mat.map) mat.map.repeat.set(1, Math.max(1, Math.floor(h/10)));
                    const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, w), mat);
                    mesh.position.set(posX, h/2, posZ); mesh.castShadow = true; mesh.receiveShadow = true; mapGroup.add(mesh);
                    if (!isTextured) { const edges = new THREE.EdgesGeometry(mesh.geometry); mesh.add(new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xaaaaaa }))); }
                } else if (cell.type === 'median') {
                    const mesh = new THREE.Mesh(new THREE.BoxGeometry(CONFIG.cellSize, 1, CONFIG.cellSize), new THREE.MeshLambertMaterial({ color: CONFIG.colors.grass }));
                    mesh.position.set(posX, CONFIG.elevationHeight, posZ); mapGroup.add(mesh);
                    const tree = new THREE.Mesh(treeGeo, treeMat); tree.position.set(posX, CONFIG.elevationHeight + 3, posZ); mapGroup.add(tree);
                    if (x%3===0 && z%3===0) { const pillar = new THREE.Mesh(pillarGeo, pillarMat); pillar.position.set(posX, CONFIG.elevationHeight/2, posZ); mapGroup.add(pillar); }
                } else if (cell.type === 'road') {
                    let yPos = 0.5;
                    let mat;
                    if (isTextured) {
                        if (cell.isIntersection && cell.isHighway) mat = roadMaterials.intersection;
                        else if (cell.isHighway) mat = roadMaterials.highway;
                        else if (cell.isIntersection) mat = roadMaterials.intersection;
                        else mat = cell.isHorizontal ? roadMaterials.horizontal : roadMaterials.vertical;
                    } else {
                        let color = CONFIG.colors.road; if (cell.isHighway) color = CONFIG.colors.highway; mat = new THREE.MeshLambertMaterial({ color: color });
                    }
                    if (cell.isElevated) yPos = CONFIG.elevationHeight; 
                    else if (cell.isBridge) yPos = CONFIG.bridgeHeight; 
                    else if (cell.isRamp) { const step = CONFIG.elevationHeight / 5; yPos = CONFIG.elevationHeight - (cell.rampLevel * step); }
                    else if (cell.isBridgeRamp) yPos = (cell.rampTargetHeight + 0.5) / 2;

                    const mesh = new THREE.Mesh(new THREE.BoxGeometry(CONFIG.cellSize, 1, CONFIG.cellSize), mat);
                    
                    if (cell.isBridgeRamp && cell.rampDir) {
                        const targetH = cell.rampTargetHeight || CONFIG.bridgeHeight;
                        const diff = targetH - 0.5;
                        const angle = Math.atan(diff / CONFIG.cellSize);
                        const len = Math.sqrt(diff*diff + CONFIG.cellSize*CONFIG.cellSize);
                        const scale = (len / CONFIG.cellSize) * 1.1; 
                        if(cell.rampDir.dx === 1) { mesh.rotation.z = angle; mesh.scale.set(scale, 1, 1); }
                        else if(cell.rampDir.dx === -1) { mesh.rotation.z = -angle; mesh.scale.set(scale, 1, 1); }
                        else if(cell.rampDir.dz === 1) { mesh.rotation.x = -angle; mesh.scale.set(1, 1, scale); }
                        else if(cell.rampDir.dz === -1) { mesh.rotation.x = angle; mesh.scale.set(1, 1, scale); }
                    }
                    
                    if (isTextured && cell.isHighway && !cell.isIntersection) {
                        const section = cell.highwaySection; const side = cell.highwaySide;
                        if (section === 'top' && side === 'outer') mesh.rotation.y = Math.PI; 
                        else if (section === 'bottom' && side === 'inner') mesh.rotation.y = Math.PI;
                        else if (section === 'left') { if (side === 'outer') mesh.rotation.y = -Math.PI / 2; if (side === 'inner') mesh.rotation.y = Math.PI / 2; }
                        else if (section === 'right') { if (side === 'inner') mesh.rotation.y = -Math.PI / 2; if (side === 'outer') mesh.rotation.y = Math.PI / 2; }
                    }

                    mesh.position.set(posX, yPos, posZ); mesh.receiveShadow = true; mesh.castShadow = cell.isElevated || cell.isBridge; mapGroup.add(mesh);
                    if (cell.isElevated && (cell.isBridge || (x%3===0 && z%3===0))) { const pillar = new THREE.Mesh(pillarGeo, pillarMat); pillar.position.set(posX, CONFIG.elevationHeight/2, posZ); mapGroup.add(pillar); }
                    if (cell.isBridge && !cell.isElevated) {
                        const p = new THREE.Mesh(bridgePillarGeo, pillarMat); p.position.set(posX, 0, posZ); mapGroup.add(p);
                        if (cell.isIntersection) { const cp = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 4, 8), pillarMat); for(let dx of [-3, 3]) for(let dz of [-3, 3]) { const c = cp.clone(); c.position.set(posX + dx, 0, posZ + dz); mapGroup.add(c); } }
                    }
                    if (cell.isRamp) { const h = yPos; const p = new THREE.Mesh(new THREE.CylinderGeometry(1,1, h, 8), pillarMat); p.position.set(posX, h/2, posZ); mapGroup.add(p); }
                    if (cell.stopLineDir) {
                        const line = new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.cellSize * 0.15, CONFIG.cellSize * 0.8), stopLineMat); line.rotation.x = -Math.PI/2;
                        if (cell.stopLineDir.dx !== 0) { line.rotation.z = 0; line.position.set(posX + (CONFIG.cellSize/2-1)*cell.stopLineDir.dx, yPos + 0.05, posZ); } 
                        else { line.rotation.z = Math.PI/2; line.position.set(posX, yPos + 0.05, posZ + (CONFIG.cellSize/2-1)*cell.stopLineDir.dz); }
                        mapGroup.add(line);
                    }
                } else if (cell.type === 'carpark') {
                    const mesh = new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.cellSize*0.9, CONFIG.cellSize*0.9), new THREE.MeshLambertMaterial({ color: CONFIG.colors.carpark })); mesh.rotation.x = -Math.PI/2; mesh.position.set(posX, 0.2, posZ); mapGroup.add(mesh);
                    const lGeo = new THREE.PlaneGeometry(CONFIG.cellSize*0.05, CONFIG.cellSize*0.6); const lMat = new THREE.MeshBasicMaterial({ color: CONFIG.colors.carparkLine });
                    const l1 = new THREE.Mesh(lGeo, lMat); l1.rotation.x = -Math.PI/2; l1.position.set(posX-2, 0.25, posZ); mapGroup.add(l1);
                    const l2 = new THREE.Mesh(lGeo, lMat); l2.rotation.x = -Math.PI/2; l2.position.set(posX+2, 0.25, posZ); mapGroup.add(l2);
                } else if (cell.type === 'path') {
                    const mesh = new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.cellSize*0.6, CONFIG.cellSize*0.6), new THREE.MeshBasicMaterial({ color: CONFIG.colors.path })); mesh.rotation.x = -Math.PI/2; mesh.position.set(posX, 0.2, posZ); mapGroup.add(mesh);
                } else if (cell.type === 'water') {
                    const mesh = new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.cellSize, CONFIG.cellSize), new THREE.MeshBasicMaterial({ color: CONFIG.colors.water })); mesh.rotation.x = -Math.PI/2; mesh.position.set(posX, 0.2, posZ); mapGroup.add(mesh);
                }
            }
        }

        const home = new THREE.Sprite(new THREE.SpriteMaterial({ map: textures.home, depthTest: false })); home.scale.set(30, 30, 1); home.position.set(80, 80, 80); iconGroup.add(home);
        const mission = new THREE.Sprite(new THREE.SpriteMaterial({ map: textures.mission, depthTest: false })); mission.scale.set(30, 30, 1); mission.position.set(-150, 80, -150); iconGroup.add(mission);

        document.getElementById('legend-container').innerHTML = `
            <div class="legend-item"><div class="dot" style="background:#555"></div> Highway</div>
            <div class="legend-item"><div class="dot" style="background:#2d5a27"></div> Median</div>
            <div class="legend-item"><div class="dot" style="background:#555; border: 1px solid yellow"></div> Bridge</div>
            <div class="legend-item"><div class="dot" style="background:#888"></div> Ramp</div>
            <div class="legend-item"><div class="dot" style="background:#CCC"></div> Street</div>
        `;
        document.getElementById('minimap-ui').style.display = 'block';
    }

    function setStage(stage) {
        console.log("Setting stage " + stage);
        currentStage = stage;
        clearMap();
        document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
        const btn = document.getElementById('btn-stage' + stage);
        if(btn) btn.classList.add('active');

        if(stage === 1) renderStage1();
        else if(stage === 2) renderStage2();
        else if(stage === 3) renderPolishStage(false);
        else if(stage === 4) renderPolishStage(true);
    }

    function onWindowResize() {
        const aspect = window.innerWidth / window.innerHeight;
        camera.aspect = aspect;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate(time) {
        requestAnimationFrame(animate);

        const dt = Math.min((time - lastTime) / 1000, 0.1) || 0.016;
        lastTime = time;

        if(currentStage >= 3) {
            updatePhysics(dt);
            updateVisuals();
        }

        controls.update();
        renderer.render(scene, camera);
    }

    init();
</script>
</body>
</html>
